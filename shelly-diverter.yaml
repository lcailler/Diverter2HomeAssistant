esphome:
  name: shelly-diverter

esp8266:          # device defintion -> https://devices.esphome.io/standards/global
  board: esp01_1m #   board defintion-> https://devices.esphome.io/devices/Shelly-1 

# Enable logging
logger:
  level: VERBOSE #makes uart stream available in esphome logstream
  baud_rate: 0 #disable logging over uartE
  tx_buffer_size : 4000

# Enable Home Assistant API
api:
  encryption:
    key: "<PKEY>="

ota:
  - platform: esphome
    password: "<PASSWORD>"

wifi:
  networks:
  - ssid: !secret wifi_fb_ssid
    password: !secret wifi_fb_password
  - ssid: !secret wifi_ext_ssid
    password: !secret wifi_ext_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Shelly-Diverter Fallback Hotspot"
    password: "<PASSWORD>"

captive_portal:

json:

uart:
  id: diverterUART
  tx_pin: GPIO1
  rx_pin: GPIO3
  baud_rate: 9600
  rx_buffer_size: 4000
  debug:
    direction: RX
    dummy_receiver: true
    after:
      #delimiter: "\r\n"
      bytes: 2000
    sequence:
      - lambda: |-
            std::string str(bytes.begin(), bytes.end());
            ESP_LOGD("uart", "Données reçues: %s", str.c_str());

            // ==== JsonDocument used to ensure flexibility and robustness of json decoding. ======
            JsonDocument doc;
            DeserializationError error = deserializeJson(doc, str);
            if (error) {
              ESP_LOGD("uart", "Erreur de parsing JSON: %s", error.c_str());
              return;
            } else {
              ESP_LOGD("uart", "json decode done OK");
            }

            // ==== Extraction of JSON fields =====================================================
            if (doc.containsKey("average_power_01min_w")) {
              float f =     doc["average_power_01min_w"];
              id(                vaill1).publish_state(f);
            }
            if (doc.containsKey("triac1_diverted_energy_wh")) {
              float f =     doc["triac1_diverted_energy_wh"];
              id(                vaill2).publish_state(f);
            }

## send recurent message 

# send message to UART at fix recurence
time:
  - platform: sntp
    id: my_time

    on_time:
      # Every 30sec
      - seconds: /30
        then:
          - uart.write:
              id: diverterUART
              data: "DIVERTER_GETJSON\n"


switch:
  - platform: uart
    id: diverter_marche_force_on
    internal: true
    name: "diverter_marche_force_on"
    data: "001_TRIAC_REQUEST_ON\n"
    send_every: 40s
  - platform: uart
    internal: true
    id : diverter_marche_force_off
    name: "diverter_marche_force_off"
    data: "002_TRIAC_REQUEST_OFF\n"

  - platform: template
    name: "ECS_marche_force"
    optimistic: true
    turn_on_action:
      then:
        - switch.turn_on: diverter_marche_force_on
    turn_off_action:
      then:
        - switch.turn_off: diverter_marche_force_on
        - delay: 1s
        - switch.turn_on: diverter_marche_force_off

sensor:
  - platform: template
    id: vaill1                         # "In/Out power" definition with robust data flow, average_power_01min_w. Stable and representative average power.
    name: "In/Out power"               # average_power_01min_w, Puissance réelle (compteur EDF), valeur moyenne sur la dernière minute
    unit_of_measurement: "W"

  - platform: template
    id: vaill2
    name: "triac1_diverted_energy"     # triac1_diverted_energy_wh, cumul de l'energie solaire divertie injectée dans le cumulus depuis la mise à ON, valeur instantanée disponnible au moment de la requête
    device_class: "energy"
    state_class: "total_increasing"
    unit_of_measurement: "Wh"
